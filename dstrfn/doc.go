/*
Package dstrfn performs functional operations in a distributed environment.

The paradigm of the package is to create a program which can be run in either master or slave mode.
In master mode, the program invokes itself on the remote execution hosts in slave mode.
The slaves contact the master to receive input and send output.
This avoids generating and compiling a new program to be executed on the remote machines.

Usage

It is important to call dstrfn.Register(), flag.Parse() and dstrfn.ExecIfSlave() in that order.
The Register function defines any tasks which will be used within the program.
It creates flags associated with each task to provide command-line control of several options.
It is possible to register more than one task.
While tasks can be defined by implementing the Task interface directly, it is most common to use dstrfn.Func() to create a Task directly from a function.
ExecIfSlave will never return if the program has been invoked in slave mode.

	func init() {
		dstrfn.Register("square", true, dstrfn.Func(
			func(x float64) float64 { return x * x },
		))
	}

	func main() {
		flag.Parse()
		dstrfn.ExecIfSlave()

		const n = 100
		x := make([]float64, n)
		for i := range x {
			x[i] = float64(i + 1)
		}

		var y []float64
		if err := dstrfn.Map("square", &y, x, nil); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
	}

This program is then invoked at the shell according to
	$ ./example -dstrfn.addr=`hostname`:12345
and the call to dstrfn.Map() will execute the command
	$ qsub [opts] -- /path/to/example -dstrfn.addr=`hostname`:12345 -dstrfn.task=square

Command line flags

The above code defines a number of additional flags.
	$ ./example -help
	Usage of ./example:
	  -dstrfn.addr="": Address of master on network.
	  -dstrfn.task="": Task to execute as slave. Empty to execute as master.
	  -square.chunk-len=1: Split into chunks of up to this many elements.
	  -square.flags="": Additional flags
	  -square.stderr=false: Keep stderr?
	  -square.stdout=false: Keep stdout?

The address must be in a format which can be used with net.Listen() and net.Dial() (for the master and slaves respectively).

The -task.flags option provides a way to specify task-dependent flags to qsub.
	$ ./example [...] -square.flags "-l mem=100m,walltime=0:15:00"
The -task.stdout and -task.stderr flags provide a way to keep the stdout and stderr files generated by the slaves.
The -task.chunk-len flag only appears if the dstrfn.Register() was called with chunk set to true.
It provides a way to perform multiple maps per task.
Note that only functions with concrete types can be used with chunking.
Specifically, types X which can be decoded from JSON into an empty slice of type []X.

Additional parameters

To call a function accepting one additional parameter which is constant for all x[i]:
	dstrfn.Register("pow", true, dstrfn.Func(math.Pow))
	// ...
	var y []float64
	err := dstrfn.Map("pow", &y, x, float64(2))

Reduce operations

Reduce operations are performed as a series of maps from a list of Pairs of X to a list of Xs.
Tasks for reducing are registered in the same way as those for mapping, however they must be called using dstrfn.Reduce() not dstrfn.Map().
Note that reduce operations defined with ReduceFunc() are incompatible with chunking because Pair has members of type interface{}.

To do a reduce operation:
	dstrfn.Register("add", false, dstrfn.ReduceFunc(
		func(x, y float64) float64 { return x + y },
	))
	// ...
	var total float64
	err := dstrfn.Reduce("add", &total, x, nil)
*/
package dstrfn
